google地图经纬度偏移修正算法完美解决方案

由于受到国家一些法律法规限制，所有的电子地图服务提供商都需要给地图数据加上偏移和加密，因此广受大家关注的google地图也不例外。但是作为一些用惯了免费服务的网友们，始终对google MAP上的标注偏移很头疼，我收集了一些资料，今天在这里和大家一起分享。

所谓的地图数据加密偏移，其实就是用一个偏移算法对地图的经纬度做一个加减偏移量，从而达到与实际地图不一致。这个偏移算法本身是没有什么规律可言的，每 家地图服务商都有一套自己的加密偏移算法，既然算法上没有什么规律可言，但是对于算法中生成的偏移量是否有规律呢？这个是可以肯定的，但是偏移算法中生成 的偏移量是有规律而言的。偏移量的规律很难得到，要是能拿到这个偏移量，就可以说是破解了某一个地图服务商的地图加密。

那我们怎么解决这个偏差呢!我在网上找到了一个强人破解google map偏移的方法

毕竟做地图开发的都存在卫星图和地图的切换，谁不想让切换以后的地图对上呢！后来我发现google的地图服务，ditu.gogle开始的都没有偏 差，maps.google开头的服务就有偏差，我就开始查找google的取偏移量算法，事前我还是图破解google手机版本的数据，没有成功，估计 是使用了自己的压缩或加密算法，最后也没有找到规律，后来才尝试破解web版本的不过web版本的接口我对于js不是特别熟悉，所以本次破解放弃了分析源 代码的步骤，而是直接采用排除法那就是把地图部分访问的全部地址，一个接一个封杀掉，查找那个起偏移做用的网址 http://ditu.google.cn/maps/vp?spn=0.0,0.0&z=18& vp=39.111195,117.148067 最后找到了就是这个，记住每次测试用清理浏览器缓存哦，使用fixfox的fildder和adblock就够了 然后就是分析每次返回内容的规律，皇天不负有心人啊，我总算是搞定了，下面是我整理的接口

Google 中国地图偏移接口 


1.      接口地址：http://ditu.google.cn/maps/vp?spn=0.0,0.0&z=18&vp=39.111195,117.148067

（注：.cn和.com都可以，我用国内服务器就会选择.cn用美国服务器就会选择.com）

2.      返回内容中的有效部分：


3.      (39.111195, 117.148067, 18, [9, -2, 18, -4, 37, -8, 74, -16, 149, -33, 298, -67, 596, -135, 1193, -270])

4.      Spn参数暂时未知实际意义，但是需要上发spn参数，任意两个小数用逗号分开Vp参数纬经度值，用逗号分隔，z参数为地图缩放级别，无实际意义

5.      取回的部分中有效数字为[9, -2, 18, -4, 37, -8, 74, -16, 149, -33, 298, -67, 596, -134, 1192, -268]这个数组总共有8组数字，每两个为一组，分为别从11级到18级的地图和卫星图的偏移像素数量，我们前一组数字精确的等于后一组数字除二，我们 为了得到最精确的偏移，故选择第18级的偏移量1193，-270，1193为x方向上精度的偏移像素，-270为y方向上维度偏移像素

6.      经纬度的偏移转换我们需要江经纬度39.111195，117.148067转化为18级像素值25620917 和 55392414，然后分别加上偏移量-270,1193,然后再转化为经纬度39.11231854918217 和117.15446412563324，即位偏移后的经纬度

google的地图采用将地球圆表面投影成平面的方式进行贴图

假设zoom=15；

横坐标从左至右像素为0-256*2的15次幂，也就是每增加一级，地图大小横纵坐标加倍，256为一个标准图片的大小

显示-180度到+180的范围，经度越大x越大

纵坐标从上到下像素为0-256*2的15次幂，显示+85到-85度的范围，纬度越小y越大

我们先看一下经度的转换

经度的转换，我就不多说了，均匀分布，大家简单的看一下下面的公式就明白了

经度到像素X值

public static double lngToPixel(double lng, int zoom) {

return (lng + 180) * (256L << zoom) / 360;

}

像素X到经度

public static double pixelToLng(double pixelX, int zoom) {

return pixelX * 360 / (256L << zoom) C 180;

}

纬度到像素Y

public static double latToPixel(double lat, int zoom) {

double siny = Math.sin(lat * Math.PI / 180);

double y = Math.log((1 + siny) / (1 C siny));

return (128 << zoom) * (1 C y / (2 * Math.PI));

}

像素Y到纬度

public static double pixelToLat(double pixelY, int zoom) {

double y = 2 * Math.PI * (1 C pixelY / (128 << zoom));

double z = Math.pow(Math.E, y);

double siny = (z C 1) / (z + 1);

return Math.asin(siny) * 180 / Math.PI;

}

维度的这个转换，单纯去理解不是很好理解，我也没有太深入的了解，从公式来 看，采用了一种非线性变化，也就是靠近赤道的地方单位像素表现的纬度间距大，越靠近两极越小，可能是因为 经度在靠近两极的方向均匀变化，导致纬度也要进行拉伸，否则  靠近两极的地方，地理形状就该发生变化了，总之上面的转换公式大家还是可以研究一下 的，google维度的表示范围是-85到+85，这个可以求出来！

上面得到的像素XY是像素的坐标，并非是google地图取地图的那个XY那个XY是把像素所标除以256得到的商，也就是每张图片的大小

